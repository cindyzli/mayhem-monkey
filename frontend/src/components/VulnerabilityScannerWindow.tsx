import { useState, useRef, useEffect, useCallback } from 'react';
import { Shield, X, Mic, MicOff } from 'lucide-react';
import { TestPanel } from './TestPanel';
import { ResultsPanel } from './ResultsPanel';
import { ScanningProgress } from './ScanningProgress';
import type { Vulnerability } from './VulnerabilityScanner';
import { transformResults } from './VulnerabilityScanner';
import { motion } from 'motion/react';

const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:5000';

export function VulnerabilityScannerWindow() {
  const [isScanning, setIsScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState(0);
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [isOpen, setIsOpen] = useState(true);
  const [targetUrl, setTargetUrl] = useState('');
  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const [selectedTests, setSelectedTests] = useState<string[]>([
    'sql-injection',
    'xss',
    'file-upload',
    'authentication',
    'encryption',
    'input-validation'
  ]);

  const [listening, setListening] = useState(false);
  const recognitionRef = useRef<any>(null);

  // Stable ref so the recognition callback always sees latest startScan
  const startScanRef = useRef<() => void>(() => {});

  const toggleListening = useCallback(() => {
    if (listening && recognitionRef.current) {
      recognitionRef.current.stop();
      setListening(false);
      return;
    }

    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.error('Speech recognition not supported');
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    recognition.onresult = (event: any) => {
      const last = event.results[event.results.length - 1];
      if (!last.isFinal) return;
      const transcript = last[0].transcript.toLowerCase().trim();
      console.log('[Voice]', transcript);

      if (transcript.includes('start scan') || transcript.includes('start scanning') || transcript.includes('run scan')) {
        startScanRef.current();
      }
    };

    recognition.onerror = (e: any) => {
      console.error('[Voice error]', e);
      setListening(false);
    };

    recognition.onend = () => {
      // Auto-restart so it keeps listening
      if (recognitionRef.current) {
        try { recognitionRef.current.start(); } catch { setListening(false); }
      }
    };

    recognitionRef.current = recognition;
    recognition.start();
    setListening(true);
  }, [listening]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.onend = null; // prevent auto-restart
        recognitionRef.current.stop();
      }
    };
  }, []);

  const startScan = async () => {
    const url = targetUrl.trim();
    if (!url) return;

    setIsScanning(true);
    setScanProgress(0);
    setVulnerabilities([]);

    try {
      const res = await fetch(`${API_BASE}/scan/start`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url }),
      });

      if (!res.ok) {
        console.error('Failed to start scan:', await res.text());
        setIsScanning(false);
        return;
      }

      pollRef.current = setInterval(async () => {
        try {
          setScanProgress(prev => Math.min(prev + 5, 90));

          const statusRes = await fetch(`${API_BASE}/scan/status`);
          const status = await statusRes.json();

          if (status.has_results) {
            if (pollRef.current) clearInterval(pollRef.current);
            setScanProgress(100);

            const resultsRes = await fetch(`${API_BASE}/results`);
            const body = await resultsRes.json();

            if (body.status === 'complete' && body.data) {
              setVulnerabilities(transformResults(body.data));
            }
            setIsScanning(false);
          } else if (!status.running) {
            if (pollRef.current) clearInterval(pollRef.current);
            setScanProgress(100);
            setIsScanning(false);
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 3000);
    } catch (err) {
      console.error('Network error:', err);
      setIsScanning(false);
    }
  };

  // Keep the ref in sync so voice callback uses latest startScan
  useEffect(() => {
    startScanRef.current = startScan;
  });

  const handleClose = () => {
    window.electronAPI?.closeScanner();
  };

  return (
    <>
    {/* Floating trigger button with dancing monkey */}
      <motion.button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-6 monkey-button right-6 text-white rounded-full p-4 shadow-[0_31.69px_63.38px_-15.211px_rgba(0,0,0,0.25)] transition-all hover:scale-110 z-[60]"
        // style={{ background: 'linear-gradient(135deg, #155DFC 0%, #00267A 100%)' }}
        className="fixed bottom-6 monkey-button right-6 text-white rounded-full p-4 shadow-[0_31.69px_63.38px_-15.211px_rgba(0,0,0,0.25)] transition-all hover:scale-110 z-[60]"
        // style={{ background: 'linear-gradient(135deg, #155DFC 0%, #00267A 100%)' }}
        aria-label="Open vulnerability scanner"
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.95 }}
      >
        <motion.div
          className="text-3xl"
          animate={{
            rotate: [0, -5, 5, -5, 5, 0],
          }}
          transition={{
            duration: 1.2,
            repeat: Infinity,
            ease: "easeInOut"
          }}
        >
          <img src="/images/dancing_monkey_transparent.gif" alt="Dancing Monkey" className="w-20 h-20" />
        </motion.div>
      </motion.button>
    <div className="w-full bg-gray-900 flex flex-col"
    style={{ height: '840px' }}>
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-800 bg-gray-900/95 backdrop-blur">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-blue-600/20 rounded-lg">
            <Shield className="w-5 h-5 text-blue-400" />
          </div>
          <div>
            <h2 className="text-lg font-bold text-white">Mayhem Monkey</h2>
            <p className="text-xs text-gray-400">Vulnerability Scanner</p>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={toggleListening}
            className={`p-2 rounded-lg transition-colors ${listening ? 'bg-red-500/20 text-red-400' : 'hover:bg-gray-800 text-gray-400'}`}
            aria-label={listening ? 'Stop listening' : 'Start voice control'}
            title={listening ? 'Listening... say "start scan"' : 'Click to enable voice control'}
          >
            {listening ? <Mic className="w-5 h-5 animate-pulse" /> : <MicOff className="w-5 h-5" />}
          </button>
          <button
            onClick={handleClose}
            className="p-2 hover:bg-gray-800 rounded-lg transition-colors"
            aria-label="Close scanner"
          >
            <X className="w-5 h-5 text-gray-400" />
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        <div className="p-4 space-y-4">
          {/* Target URL */}
          <div className="bg-gray-800/50 border border-gray-700 rounded-lg p-4">
            <label className="block text-sm font-medium text-gray-300 mb-2">Target URL</label>
            <input
              type="url"
              value={targetUrl}
              onChange={e => setTargetUrl(e.target.value)}
              placeholder="https://example.com"
              disabled={isScanning}
              className="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:opacity-50"
            />
          </div>

          <TestPanel 
            selectedTests={selectedTests}
            onTestsChange={setSelectedTests}
            onStartScan={startScan}
            isScanning={isScanning || !targetUrl.trim()}
          />

          {isScanning && (
            <ScanningProgress progress={scanProgress} />
          )}

          {!isScanning && vulnerabilities.length > 0 && (
            <ResultsPanel vulnerabilities={vulnerabilities} />
          )}

          {!isScanning && vulnerabilities.length === 0 && (
            <div className="bg-gray-800/50 border border-gray-700 rounded-lg p-6 text-center">
              <Shield className="w-10 h-10 text-gray-600 mx-auto mb-3" />
              <h3 className="text-base font-medium text-gray-300 mb-2">Ready to Scan</h3>
              <p className="text-gray-500 text-sm">
                Select tests and click "Start Scan" to analyze your code.
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  </>
  );
}
