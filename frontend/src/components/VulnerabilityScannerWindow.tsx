import { useState, useRef, useEffect, useCallback } from 'react';
import { Shield, X, Mic, MicOff } from 'lucide-react';
import { TestPanel } from './TestPanel';
import { ResultsPanel } from './ResultsPanel';
import type { Vulnerability } from './VulnerabilityScanner';
import { transformResults } from './VulnerabilityScanner';
import { motion } from 'motion/react';

const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:8000';

export function VulnerabilityScannerWindow() {
  const [isScanning, setIsScanning] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [isOpen, setIsOpen] = useState(true);
  const [targetUrl, setTargetUrl] = useState('');
  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const scannerStartedRef = useRef(false);
  const [selectedTests, setSelectedTests] = useState<string[]>([
    'sql-injection',
    'xss'
  ]);

  const [listening, setListening] = useState(false);
  const recognitionRef = useRef<any>(null);

  // Stable ref so the recognition callback always sees latest startScan
  const startScanRef = useRef<() => void>(() => { });

  const toggleListening = useCallback(() => {
    if (listening && recognitionRef.current) {
      recognitionRef.current.stop();
      setListening(false);
      return;
    }

    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.error('Speech recognition not supported');
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    recognition.onresult = (event: any) => {
      const last = event.results[event.results.length - 1];
      if (!last.isFinal) return;
      const transcript = last[0].transcript.toLowerCase().trim();
      console.log('[Voice]', transcript);

      if (transcript.includes('start scan') || transcript.includes('start scanning') || transcript.includes('run scan')) {
        startScanRef.current();
      }
    };

    recognition.onerror = (e: any) => {
      console.error('[Voice error]', e);
      setListening(false);
    };

    recognition.onend = () => {
      // Auto-restart so it keeps listening
      if (recognitionRef.current) {
        try { recognitionRef.current.start(); } catch { setListening(false); }
      }
    };

    recognitionRef.current = recognition;
    recognition.start();
    setListening(true);
  }, [listening]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.onend = null; // prevent auto-restart
        recognitionRef.current.stop();
      }
      if (pollRef.current) {
        clearInterval(pollRef.current);
      }
    };
  }, []);

  const startScan = async () => {
    const url = targetUrl.trim();

    if (pollRef.current) {
      clearInterval(pollRef.current);
      pollRef.current = null;
    }
    scannerStartedRef.current = false;
    setVulnerabilities([]);

    // With a URL: POST to start capture + open_url + scanner
    // Without a URL: GET to start capture + open_url (voice pipeline), wait for voice URL
    const requestInit: RequestInit | undefined = url
      ? {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url }),
      }
      : undefined;

    if (url) {
      setIsScanning(true);
      setIsListening(false);
    } else {
      setIsListening(true);
      setIsScanning(false);
    }

    try {
      const res = await fetch(`${API_BASE}/start`, requestInit);

      if (!res.ok) {
        console.error('Failed to start:', await res.text());
        setIsScanning(false);
        setIsListening(false);
        return;
      }

      pollRef.current = setInterval(async () => {
        try {
          const statusRes = await fetch(`${API_BASE}/scan/status`);
          const status = await statusRes.json();

          if (status.running && !scannerStartedRef.current) {
            // Scanner just started (e.g. voice detected a URL)
            scannerStartedRef.current = true;
            setIsListening(false);
            setIsScanning(true);
          }



          if (status.has_results) {
            if (pollRef.current) clearInterval(pollRef.current);

            const resultsRes = await fetch(`${API_BASE}/results`);
            const body = await resultsRes.json();

            if (body.status === 'complete' && body.data) {
              console.log(body.data);
              setVulnerabilities(transformResults(body.data));
            }
            setIsScanning(false);
            setIsListening(false);
            scannerStartedRef.current = false;
          } else if (status.running === false && scannerStartedRef.current) {
            if (pollRef.current) clearInterval(pollRef.current);
            setIsScanning(false);
            setIsListening(false);
            scannerStartedRef.current = false;
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 3000);
    } catch (err) {
      console.error('Network error:', err);
      setIsScanning(false);
      setIsListening(false);
    }
  };

  // Keep the ref in sync so voice callback uses latest startScan
  useEffect(() => {
    startScanRef.current = startScan;
  });

  const handleClose = () => {
    window.electronAPI?.closeScanner();
  };

  return (
    <>
      {/* Floating trigger button with dancing monkey */}
      <motion.button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-6 monkey-button right-6 text-white rounded-full p-4 shadow-[0_31.69px_63.38px_-15.211px_rgba(0,0,0,0.25)] transition-all hover:scale-110 z-[60]"
        // style={{ background: 'linear-gradient(135deg, #155DFC 0%, #00267A 100%)' }}
        aria-label="Open vulnerability scanner"
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.95 }}
      >
        <motion.div
          className="text-3xl"
          animate={{
            rotate: [0, -5, 5, -5, 5, 0],
          }}
          transition={{
            duration: 1.2,
            repeat: Infinity,
            ease: "easeInOut"
          }}
        >
          <img src="/images/dancing_monkey_transparent.gif" alt="Dancing Monkey" className="w-20 h-20" />
        </motion.div>
      </motion.button>
      <div className="w-full bg-gray-900 flex flex-col"
        style={{ height: '840px' }}>
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-800 bg-gray-900/95 backdrop-blur">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-600/20 rounded-lg">
              <Shield className="w-5 h-5 text-blue-400" />
            </div>
            <div>
              <h2 className="text-lg font-bold text-white">Mayhem Monkey</h2>
              <p className="text-xs text-gray-400">Vulnerability Scanner</p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={toggleListening}
              className={`p-2 rounded-lg transition-colors ${listening ? 'bg-red-500/20 text-red-400' : 'hover:bg-gray-800 text-gray-400'}`}
              aria-label={listening ? 'Stop listening' : 'Start voice control'}
              title={listening ? 'Listening... say "start scan"' : 'Click to enable voice control'}
            >
              {listening ? <Mic className="w-5 h-5 animate-pulse" /> : <MicOff className="w-5 h-5" />}
            </button>
            <button
              onClick={handleClose}
              className="p-2 hover:bg-gray-800 rounded-lg transition-colors"
              aria-label="Close scanner"
            >
              <X className="w-5 h-5 text-gray-400" />
            </button>
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto">
          <div className="p-4 space-y-4">
            {/* Target URL */}
            <div className="bg-gray-800/50 border border-gray-700 rounded-lg p-4">
              <label className="block text-sm font-medium text-gray-300 mb-2">Target URL</label>
              <input
                type="url"
                value={targetUrl}
                onChange={e => setTargetUrl(e.target.value)}
                placeholder="https://example.com"
                disabled={isScanning}
                className="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:opacity-50"
              />
            </div>

            <TestPanel
              selectedTests={selectedTests}
              onTestsChange={setSelectedTests}
              onStartScan={startScan}
              isScanning={isScanning}
              isListening={isListening}
              disabled={isScanning || isListening}
            />

            {!isScanning && !isListening && vulnerabilities.length > 0 && (
              <ResultsPanel vulnerabilities={vulnerabilities} />
            )}
          </div>
        </div>
      </div>
    </>
  );
}
